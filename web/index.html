<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2048 Classic</title>
  <style>
    :root {
      --bg: #faf8ef;
      --board: #bbada0;
      --cell: rgba(238, 228, 218, 0.35);
      --font: "Clear Sans", "Helvetica Neue", Arial, sans-serif;
      --text: #776e65;
      --bright: #f9f6f2;
      --gap: 12px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 24px;
      background: var(--bg);
      color: var(--text);
      font-family: var(--font);
      display: flex;
      justify-content: center;
    }
    .wrapper { width: 420px; max-width: 100%; }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    h1 { margin: 0; font-size: 48px; letter-spacing: 1px; }
    .scores { display: flex; gap: 8px; }
    .score-box {
      background: var(--board);
      color: var(--bright);
      padding: 8px 12px;
      border-radius: 4px;
      text-align: center;
      min-width: 80px;
    }
    .score-box .label { font-size: 12px; text-transform: uppercase; }
    .score-box .value { font-size: 20px; font-weight: bold; }
    .top-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 12px;
      gap: 12px;
    }
    .instructions { font-size: 14px; line-height: 1.4; margin: 0; }
    button {
      padding: 10px 16px;
      border: none;
      background: #8f7a66;
      color: var(--bright);
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      white-space: nowrap;
    }
    button:hover { background: #9f8b76; }
    .board {
      margin-top: 18px;
      background: var(--board);
      border-radius: 6px;
      padding: var(--gap);
      position: relative;
      width: 100%;
      aspect-ratio: 1 / 1;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
      overflow: hidden;
    }
    .grid {
      position: absolute;
      inset: var(--gap);
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(4, 1fr);
      gap: var(--gap);
    }
    .cell {
      background: var(--cell);
      border-radius: 4px;
    }
    .tiles {
      position: absolute;
      inset: var(--gap);
      pointer-events: none;
    }
    .tile {
      position: absolute;
      width: calc((100% - (var(--gap) * 3)) / 4);
      height: calc((100% - (var(--gap) * 3)) / 4);
      border-radius: 6px;
      --tx: 0px;
      --ty: 0px;
      transform: translate(var(--tx), var(--ty));
      transition: transform 140ms ease;
    }
    .tile-inner {
      width: 100%;
      height: 100%;
      border-radius: inherit;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      font-weight: bold;
      transition: background 140ms ease, color 140ms ease;
    }
    .tile-inner.tile-small { font-size: 26px; }
    .tile-inner.tile-tiny { font-size: 20px; }
    .tile-inner.tile-new { animation: pop 180ms ease; animation-fill-mode: both; }
    .tile-inner.tile-merged { animation: bump 200ms ease; animation-fill-mode: both; }
    @keyframes pop { 0% { transform: scale(0); } 100% { transform: scale(1); } }
    @keyframes bump { 0% { transform: scale(1.15); } 100% { transform: scale(1); } }
    .game-over {
      position: absolute;
      inset: 0;
      background: rgba(238, 228, 218, 0.73);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      font-weight: bold;
      color: #776e65;
      z-index: 5;
      flex-direction: column;
      gap: 12px;
    }
    .hidden { display: none; }
    @media (max-width: 520px) {
      body { padding: 16px; }
      h1 { font-size: 38px; }
      .tile { font-size: 26px; }
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <header>
      <h1>2048</h1>
      <div class="scores">
        <div class="score-box">
          <div class="label">score</div>
          <div id="score" class="value">0</div>
        </div>
        <div class="score-box">
          <div class="label">best</div>
          <div id="best" class="value">0</div>
        </div>
      </div>
    </header>
    <div class="top-row">
      <p class="instructions">按方向键或滑动，合并方块，冲击 2048！</p>
      <button id="newGame">新游戏</button>
    </div>
    <div class="board" id="board">
      <div class="grid" aria-hidden="true"></div>
      <div class="tiles" id="tiles"></div>
      <div id="overlay" class="game-over hidden">
        <div id="overlayText">游戏结束</div>
        <button id="restart">再来一局</button>
      </div>
    </div>
  </div>
  <script>
    const gridSize = 4;
    const boardEl = document.getElementById('board');
    const tilesEl = document.getElementById('tiles');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const overlayText = document.getElementById('overlayText');
    const newGameBtn = document.getElementById('newGame');
    const restartBtn = document.getElementById('restart');

    let grid = createEmpty();
    let score = 0;
    let best = Number(localStorage.getItem('best-2048') || 0);
    let isAnimating = false;
    let animations = [];
    let lastAdded = null;

    bestEl.textContent = best;
    buildGrid();
    startGame();

    newGameBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', startGame);
    window.addEventListener('keydown', handleKey);
    addSwipe(boardEl, handleSwipe);
    window.addEventListener('resize', () => render());

    function startGame() {
      grid = createEmpty();
      score = 0;
      overlay.classList.add('hidden');
      lastAdded = null;
      addRandomTile();
      addRandomTile();
      updateScore(0, true);
      render();
    }

    function createEmpty() {
      return Array.from({ length: gridSize }, () => Array(gridSize).fill(0));
    }

    function buildGrid() {
      const gridLayer = boardEl.querySelector('.grid');
      gridLayer.innerHTML = '';
      for (let i = 0; i < gridSize * gridSize; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        gridLayer.appendChild(cell);
      }
    }

    function addRandomTile() {
      const empties = [];
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          if (!grid[r][c]) empties.push({ r, c });
        }
      }
      if (!empties.length) return false;
      const spot = empties[Math.floor(Math.random() * empties.length)];
      grid[spot.r][spot.c] = Math.random() < 0.9 ? 2 : 4;
      lastAdded = spot;
      return true;
    }

    function handleKey(e) {
      const map = {
        ArrowUp: { x: 0, y: -1 },
        ArrowDown: { x: 0, y: 1 },
        ArrowLeft: { x: -1, y: 0 },
        ArrowRight: { x: 1, y: 0 },
      };
      if (!map[e.key] || isAnimating) return;
      e.preventDefault();
      move(map[e.key]);
    }

    function handleSwipe(direction) {
      if (isAnimating) return;
      const map = {
        up: { x: 0, y: -1 },
        down: { x: 0, y: 1 },
        left: { x: -1, y: 0 },
        right: { x: 1, y: 0 },
      };
      if (map[direction]) move(map[direction]);
    }

    function move(vector) {
      animations = [];
      lastAdded = null;
      const positions = buildPositions(vector);
      let moved = false;
      const mergedThisTurn = createEmpty().map(row => row.map(() => false));
      const previous = cloneGrid(grid);

      positions.forEach(({ r, c }) => {
        const value = grid[r][c];
        if (!value) return;
        let { r: nextR, c: nextC } = findFarthest(r, c, vector);
        const nextAfter = { r: nextR + vector.y, c: nextC + vector.x };
        if (within(nextAfter) && grid[nextAfter.r][nextAfter.c] === value && !mergedThisTurn[nextAfter.r][nextAfter.c]) {
          grid[nextAfter.r][nextAfter.c] *= 2;
          grid[r][c] = 0;
          mergedThisTurn[nextAfter.r][nextAfter.c] = true;
          animations.push({ from: { r, c }, to: { r: nextAfter.r, c: nextAfter.c }, merged: true });
          updateScore(grid[nextAfter.r][nextAfter.c]);
          moved = true;
        } else if (nextR !== r || nextC !== c) {
          grid[nextR][nextC] = value;
          grid[r][c] = 0;
          animations.push({ from: { r, c }, to: { r: nextR, c: nextC }, merged: false });
          moved = true;
        }
      });

      if (moved) {
        addRandomTile();
        render(previous);
        checkEnd();
      }
    }

    function buildPositions(vector) {
      const positions = [];
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) positions.push({ r, c });
      }
      if (vector.x === 1) positions.sort((a, b) => b.c - a.c);
      if (vector.x === -1) positions.sort((a, b) => a.c - b.c);
      if (vector.y === 1) positions.sort((a, b) => b.r - a.r);
      if (vector.y === -1) positions.sort((a, b) => a.r - b.r);
      return positions;
    }

    function findFarthest(r, c, v) {
      let prev;
      do {
        prev = { r, c };
        r += v.y;
        c += v.x;
      } while (within({ r, c }) && !grid[r][c]);
      return prev;
    }

    function within(pos) {
      return pos.r >= 0 && pos.r < gridSize && pos.c >= 0 && pos.c < gridSize;
    }

    function updateScore(add, reset = false) {
      score = reset ? add : score + add;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        bestEl.textContent = best;
        localStorage.setItem('best-2048', best);
      }
    }

    function checkEnd() {
      if (has2048()) showOverlay('你赢了！');
      else if (!movesAvailable()) showOverlay('游戏结束');
    }

    function has2048() {
      return grid.some(row => row.some(v => v === 2048));
    }

    function movesAvailable() {
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          const value = grid[r][c];
          if (!value) return true;
          const dirs = [ { x: 1, y: 0 }, { x: -1, y: 0 }, { x: 0, y: 1 }, { x: 0, y: -1 } ];
          if (dirs.some(v => {
            const nr = r + v.y, nc = c + v.x;
            return within({ r: nr, c: nc }) && (grid[nr][nc] === 0 || grid[nr][nc] === value);
          })) return true;
        }
      }
      return false;
    }

    function showOverlay(text) {
      overlayText.textContent = text;
      overlay.classList.remove('hidden');
    }

    function render(prevGrid = null) {
      isAnimating = true;
      tilesEl.innerHTML = '';
      const usedAnimations = [];

      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          const value = grid[r][c];
          if (!value) continue;

          const animIndex = animations.findIndex(a => a.to.r === r && a.to.c === c && !usedAnimations.includes(a));
          const anim = animIndex > -1 ? animations[animIndex] : null;
          if (anim) usedAnimations.push(anim);

          const tile = document.createElement('div');
          tile.className = 'tile';

          const inner = document.createElement('div');
          inner.className = 'tile-inner';
          inner.style.background = tileColors(value).bg;
          inner.style.color = tileColors(value).fg;
          if (value > 512) inner.classList.add('tile-tiny');
          else if (value > 64) inner.classList.add('tile-small');

          const startPos = anim ? translate(anim.from.c, anim.from.r) : translate(c, r);
          const endPos = translate(c, r);
          tile.style.setProperty('--tx', `${startPos.x}px`);
          tile.style.setProperty('--ty', `${startPos.y}px`);
          tile.style.transform = `translate(${startPos.x}px, ${startPos.y}px)`;
          inner.textContent = value;

          const isNew = lastAdded && lastAdded.r === r && lastAdded.c === c;
          if (isNew) inner.classList.add('tile-new');
          if (anim?.merged) inner.classList.add('tile-merged');

          tile.appendChild(inner);
          tilesEl.appendChild(tile);
          requestAnimationFrame(() => {
            tile.style.setProperty('--tx', `${endPos.x}px`);
            tile.style.setProperty('--ty', `${endPos.y}px`);
            tile.style.transform = `translate(${endPos.x}px, ${endPos.y}px)`;
          });
        }
      }
      requestAnimationFrame(() => { isAnimating = false; });
    }

    function translate(x, y) {
      const { gap, size } = getMetrics();
      const offsetX = x * (size + gap);
      const offsetY = y * (size + gap);
      return { x: offsetX, y: offsetY };
    }

    function getMetrics() {
      const styles = getComputedStyle(document.documentElement);
      const gap = parseFloat(styles.getPropertyValue('--gap')) || 12;
      const size = (tilesEl.clientWidth - gap * (gridSize - 1)) / gridSize;
      return { gap, size };
    }

    function tileColors(value) {
      const map = {
        2: { bg: '#eee4da', fg: '#776e65' },
        4: { bg: '#ede0c8', fg: '#776e65' },
        8: { bg: '#f2b179', fg: '#f9f6f2' },
        16: { bg: '#f59563', fg: '#f9f6f2' },
        32: { bg: '#f67c5f', fg: '#f9f6f2' },
        64: { bg: '#f65e3b', fg: '#f9f6f2' },
        128: { bg: '#edcf72', fg: '#f9f6f2' },
        256: { bg: '#edcc61', fg: '#f9f6f2' },
        512: { bg: '#edc850', fg: '#f9f6f2' },
        1024: { bg: '#edc53f', fg: '#f9f6f2' },
        2048: { bg: '#edc22e', fg: '#f9f6f2' },
      };
      return map[value] || { bg: '#3c3a32', fg: '#f9f6f2' };
    }

    function addSwipe(el, callback) {
      let startX = 0, startY = 0;
      el.addEventListener('touchstart', e => {
        const t = e.touches[0];
        startX = t.clientX; startY = t.clientY;
      }, { passive: true });
      el.addEventListener('touchend', e => {
        const t = e.changedTouches[0];
        const dx = t.clientX - startX;
        const dy = t.clientY - startY;
        const absX = Math.abs(dx), absY = Math.abs(dy);
        if (Math.max(absX, absY) < 20) return;
        callback(absX > absY ? (dx > 0 ? 'right' : 'left') : (dy > 0 ? 'down' : 'up'));
      });
    }

    function cloneGrid(g) {
      return g.map(row => row.slice());
    }
  </script>
</body>
</html>
