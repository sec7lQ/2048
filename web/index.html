<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2048 Classic</title>
  <style>
    :root {
      --bg: #faf8ef;
      --board: #bbada0;
      --cell: rgba(238, 228, 218, 0.35);
      --font: "Clear Sans", "Helvetica Neue", Arial, sans-serif;
      --text: #776e65;
      --bright: #f9f6f2;
      --gap: 12px;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overscroll-behavior-y: none;
      touch-action: none;
    }
    body {
      padding: 24px;
      background: var(--bg);
      color: var(--text);
      font-family: var(--font);
      display: flex;
      justify-content: center;
      overflow: hidden;
    }
    .wrapper { width: 420px; max-width: 100%; }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    h1 { margin: 0; font-size: 48px; letter-spacing: 1px; }
    .scores { display: flex; gap: 8px; }
    .score-box {
      background: var(--board);
      color: var(--bright);
      padding: 8px 12px;
      border-radius: 4px;
      text-align: center;
      min-width: 80px;
    }
    .score-box .label { font-size: 12px; text-transform: uppercase; }
    .score-box .value { font-size: 20px; font-weight: bold; }
    .top-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 12px;
      gap: 12px;
    }
    .size-toggle {
      margin-top: 12px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }
    .size-toggle button {
      padding: 4px 10px;
      font-size: 16px;
    }
    .size-toggle span {
      min-width: 48px;
      text-align: center;
    }
    .history {
      margin-top: 16px;
      font-size: 13px;
      color: #776e65;
    }
    .history-title {
      font-weight: bold;
      margin-bottom: 4px;
    }
    .history-list {
      max-height: 180px;
      overflow-y: auto;
      border-radius: 4px;
      background: rgba(238, 228, 218, 0.35);
      padding: 6px 8px;
    }
    .history-item {
      padding: 2px 0;
      border-bottom: 1px solid rgba(187, 173, 160, 0.25);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .history-item:last-child {
      border-bottom: none;
    }
    .history-delete {
      margin-left: 8px;
      padding: 0;
      width: 20px;
      height: 20px;
      font-size: 13px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #d9534f;
      color: #f9f6f2;
      border-radius: 3px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 120ms ease;
    }
    .history-item:hover .history-delete,
    .history-item.show-delete .history-delete {
      opacity: 1;
      pointer-events: auto;
    }
    .history-delete:hover,
    .history-delete:active,
    .history-delete:focus {
      background: #d9534f;
      color: #f9f6f2;
      outline: none;
    }
    .instructions { font-size: 14px; line-height: 1.4; margin: 0; }
    button {
      padding: 10px 16px;
      border: none;
      background: #8f7a66;
      color: var(--bright);
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      white-space: nowrap;
    }
    button:hover { background: #9f8b76; }
    .board {
      margin-top: 18px;
      background: var(--board);
      border-radius: 6px;
      padding: var(--gap);
      position: relative;
      width: 100%;
      aspect-ratio: 1 / 1;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
      overflow: hidden;
    }
    .grid {
      position: absolute;
      inset: var(--gap);
      display: grid;
      grid-template-columns: repeat(var(--grid-size, 4), 1fr);
      grid-template-rows: repeat(var(--grid-size, 4), 1fr);
      gap: var(--gap);
    }
    .cell {
      background: var(--cell);
      border-radius: 4px;
    }
    .tiles {
      position: absolute;
      inset: var(--gap);
      pointer-events: none;
    }
    .tile {
      position: absolute;
      border-radius: 6px;
      --tx: 0px;
      --ty: 0px;
      /* 使用 GPU 加速并支持高刷屏幕的平滑动画 */
      will-change: transform;
      transform: translate3d(var(--tx), var(--ty), 0);
      transition: transform 120ms ease-out;
    }
    .tile-inner {
      width: 100%;
      height: 100%;
      border-radius: inherit;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      font-weight: bold;
      transition: background 140ms ease, color 140ms ease;
    }
    .tile-inner.tile-small { font-size: 26px; }
    .tile-inner.tile-tiny { font-size: 20px; }
    .tile-inner.tile-new { animation: pop 180ms ease; animation-fill-mode: both; }
    .tile-inner.tile-merged { animation: bump 200ms ease; animation-fill-mode: both; }
    @keyframes pop { 0% { transform: scale(0); } 100% { transform: scale(1); } }
    @keyframes bump { 0% { transform: scale(1.15); } 100% { transform: scale(1); } }
    .game-over {
      position: absolute;
      inset: 0;
      background: rgba(238, 228, 218, 0.73);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      font-weight: bold;
      color: #776e65;
      z-index: 5;
      flex-direction: column;
      gap: 12px;
    }
    .hidden { display: none; }
    @media (max-width: 520px) {
      body { padding: 16px; }
      h1 { font-size: 38px; }
      .tile { font-size: 26px; }
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <header>
      <h1>2048</h1>
      <div class="scores">
        <div class="score-box">
          <div class="label">score</div>
          <div id="score" class="value">0</div>
        </div>
        <div class="score-box">
          <div class="label">best</div>
          <div id="best" class="value">0</div>
        </div>
        <div class="score-box">
          <div class="label">time</div>
          <div id="time" class="value">0:00</div>
        </div>
      </div>
    </header>
    <div class="top-row">
      <p class="instructions">按方向键或滑动，合并方块，冲击 2048！</p>
      <button id="newGame">新游戏</button>
    </div>
    <div class="board" id="board">
      <div class="grid" aria-hidden="true"></div>
      <div class="tiles" id="tiles"></div>
      <div id="overlay" class="game-over hidden">
        <div id="overlayText">游戏结束</div>
        <button id="restart">再来一局</button>
      </div>
    </div>
    <div class="size-toggle">
      <button id="sizePrev" aria-label="降低难度">&lt;</button>
      <span id="sizeLabel">4×4</span>
      <button id="sizeNext" aria-label="提高难度">&gt;</button>
    </div>
    <div class="history">
      <div class="history-title">对局记录</div>
      <div id="historyList" class="history-list">暂无对局</div>
    </div>
  </div>
  <script>
    let gridSize = 4;
    const boardEl = document.getElementById('board');
    const tilesEl = document.getElementById('tiles');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const timeEl = document.getElementById('time');
    const overlay = document.getElementById('overlay');
    const overlayText = document.getElementById('overlayText');
    const newGameBtn = document.getElementById('newGame');
    const restartBtn = document.getElementById('restart');
    const sizePrev = document.getElementById('sizePrev');
    const sizeNext = document.getElementById('sizeNext');
    const sizeLabel = document.getElementById('sizeLabel');
    const historyListEl = document.getElementById('historyList');

    const sizes = [4, 5, 6, 7, 8];
    let sizeIndex = sizes.indexOf(gridSize);

    let grid = createEmpty();
    let score = 0;
    let hasPlayedCurrentGame = false;
    let bestBySize = loadBestBySize();
    let best = bestBySize[gridSize] || 0;
    let isAnimating = false;
    let animations = [];
    let lastAdded = null;
    let gameStartTime = null;
    let gameTimerId = null;
    let historyRecords = loadHistory();
    const historySwipeState = {
      item: null,
      startX: 0,
      startY: 0,
      active: false,
      moved: false,
    };

    bestEl.textContent = best;
    applySize();
    renderHistory();

    newGameBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', startGame);
    sizePrev.addEventListener('click', () => {
      if (sizeIndex <= 0) return;
      sizeIndex -= 1;
      applySize();
    });
    sizeNext.addEventListener('click', () => {
      if (sizeIndex >= sizes.length - 1) return;
      sizeIndex += 1;
      applySize();
    });
    window.addEventListener('keydown', handleKey);
    addSwipe(window, handleSwipe);
    window.addEventListener('resize', () => render());
    window.addEventListener('beforeunload', handleBeforeUnload);
    if (historyListEl) {
      historyListEl.addEventListener('click', handleHistoryClick);
      setupHistorySwipe();
    }

    function startGame() {
      // 如果上一局还在进行中（还在计时），先写入一条对局记录
      if (gameStartTime) {
        finishTimerAndRecord();
      }
      hasPlayedCurrentGame = false;
      grid = createEmpty();
      score = 0;
      overlay.classList.add('hidden');
      lastAdded = null;
      startTimer();
      addRandomTile();
      addRandomTile();
      updateScore(0, true);
      render();
    }

    function applySize() {
      gridSize = sizes[sizeIndex];
      document.documentElement.style.setProperty('--grid-size', gridSize);
      sizeLabel.textContent = `${gridSize}×${gridSize}`;
      // 切换棋盘时更新对应尺寸的最高分显示
      const sizeKey = String(gridSize);
      best = bestBySize[sizeKey] || 0;
      bestEl.textContent = best;
      buildGrid();
      startGame();
    }

    function createEmpty() {
      return Array.from({ length: gridSize }, () => Array(gridSize).fill(0));
    }

    function buildGrid() {
      const gridLayer = boardEl.querySelector('.grid');
      gridLayer.innerHTML = '';
      for (let i = 0; i < gridSize * gridSize; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        gridLayer.appendChild(cell);
      }
    }

    function addRandomTile() {
      const empties = [];
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          if (!grid[r][c]) empties.push({ r, c });
        }
      }
      if (!empties.length) return false;
      const spot = empties[Math.floor(Math.random() * empties.length)];
      grid[spot.r][spot.c] = Math.random() < 0.9 ? 2 : 4;
      lastAdded = spot;
      return true;
    }

    function startTimer() {
      if (!timeEl) return;
      if (gameTimerId) clearInterval(gameTimerId);
      gameStartTime = Date.now();
      updateTime();
      gameTimerId = setInterval(updateTime, 1000);
    }

    function stopTimer() {
      if (gameTimerId) {
        clearInterval(gameTimerId);
        gameTimerId = null;
      }
    }

    function updateTime() {
      if (!timeEl) return;
      if (!gameStartTime) {
        timeEl.textContent = '0:00';
        return;
      }
      const elapsedSec = Math.floor((Date.now() - gameStartTime) / 1000);
      timeEl.textContent = formatSeconds(elapsedSec);
    }

    function handleKey(e) {
      const map = {
        ArrowUp: { x: 0, y: -1 },
        ArrowDown: { x: 0, y: 1 },
        ArrowLeft: { x: -1, y: 0 },
        ArrowRight: { x: 1, y: 0 },
      };
      if (!map[e.key] || isAnimating) return;
      e.preventDefault();
      move(map[e.key]);
    }

    function handleSwipe(direction) {
      if (isAnimating) return;
      const map = {
        up: { x: 0, y: -1 },
        down: { x: 0, y: 1 },
        left: { x: -1, y: 0 },
        right: { x: 1, y: 0 },
      };
      if (map[direction]) move(map[direction]);
    }

    function move(vector) {
      animations = [];
      lastAdded = null;
      const positions = buildPositions(vector);
      let moved = false;
      const mergedThisTurn = createEmpty().map(row => row.map(() => false));
      const previous = cloneGrid(grid);

      positions.forEach(({ r, c }) => {
        const value = grid[r][c];
        if (!value) return;
        let { r: nextR, c: nextC } = findFarthest(r, c, vector);
        const nextAfter = { r: nextR + vector.y, c: nextC + vector.x };
        if (within(nextAfter) && grid[nextAfter.r][nextAfter.c] === value && !mergedThisTurn[nextAfter.r][nextAfter.c]) {
          grid[nextAfter.r][nextAfter.c] *= 2;
          grid[r][c] = 0;
          mergedThisTurn[nextAfter.r][nextAfter.c] = true;
          animations.push({ from: { r, c }, to: { r: nextAfter.r, c: nextAfter.c }, merged: true });
          updateScore(grid[nextAfter.r][nextAfter.c]);
          moved = true;
        } else if (nextR !== r || nextC !== c) {
          grid[nextR][nextC] = value;
          grid[r][c] = 0;
          animations.push({ from: { r, c }, to: { r: nextR, c: nextC }, merged: false });
          moved = true;
        }
      });

      if (moved) {
        hasPlayedCurrentGame = true;
        addRandomTile();
        render(previous);
        checkEnd();
      }
    }

    function buildPositions(vector) {
      const positions = [];
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) positions.push({ r, c });
      }
      if (vector.x === 1) positions.sort((a, b) => b.c - a.c);
      if (vector.x === -1) positions.sort((a, b) => a.c - b.c);
      if (vector.y === 1) positions.sort((a, b) => b.r - a.r);
      if (vector.y === -1) positions.sort((a, b) => a.r - b.r);
      return positions;
    }

    function findFarthest(r, c, v) {
      let prev;
      do {
        prev = { r, c };
        r += v.y;
        c += v.x;
      } while (within({ r, c }) && !grid[r][c]);
      return prev;
    }

    function within(pos) {
      return pos.r >= 0 && pos.r < gridSize && pos.c >= 0 && pos.c < gridSize;
    }

    function updateScore(add, reset = false) {
      score = reset ? add : score + add;
      scoreEl.textContent = score;
      const sizeKey = String(gridSize);
      const currentBest = bestBySize[sizeKey] || 0;
      if (score > currentBest) {
        bestBySize[sizeKey] = score;
        best = score;
        bestEl.textContent = best;
        saveBestBySize();
      }
    }

    function checkEnd() {
      if (!movesAvailable()) endGame('游戏结束');
    }

    function movesAvailable() {
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          const value = grid[r][c];
          if (!value) return true;
          const dirs = [ { x: 1, y: 0 }, { x: -1, y: 0 }, { x: 0, y: 1 }, { x: 0, y: -1 } ];
          if (dirs.some(v => {
            const nr = r + v.y, nc = c + v.x;
            return within({ r: nr, c: nc }) && (grid[nr][nc] === 0 || grid[nr][nc] === value);
          })) return true;
        }
      }
      return false;
    }

    function endGame(text) {
      overlayText.textContent = text;
      overlay.classList.remove('hidden');
      finishTimerAndRecord();
    }

    function render(prevGrid = null) {
      isAnimating = true;
      tilesEl.innerHTML = '';
      const usedAnimations = [];
      const metrics = getMetrics();

      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          const value = grid[r][c];
          if (!value) continue;

          const animIndex = animations.findIndex(a => a.to.r === r && a.to.c === c && !usedAnimations.includes(a));
          const anim = animIndex > -1 ? animations[animIndex] : null;
          if (anim) usedAnimations.push(anim);

          const tile = document.createElement('div');
          tile.className = 'tile';
          tile.style.width = `${metrics.size}px`;
          tile.style.height = `${metrics.size}px`;

          const inner = document.createElement('div');
          inner.className = 'tile-inner';
          inner.style.background = tileColors(value).bg;
          inner.style.color = tileColors(value).fg;
          if (value > 512) inner.classList.add('tile-tiny');
          else if (value > 64) inner.classList.add('tile-small');

          const startPos = anim ? translate(anim.from.c, anim.from.r) : translate(c, r);
          const endPos = translate(c, r);
          tile.style.setProperty('--tx', `${startPos.x}px`);
          tile.style.setProperty('--ty', `${startPos.y}px`);
          inner.textContent = value;

          const isNew = lastAdded && lastAdded.r === r && lastAdded.c === c;
          if (isNew) inner.classList.add('tile-new');
          if (anim?.merged) inner.classList.add('tile-merged');

          tile.appendChild(inner);
          tilesEl.appendChild(tile);
          requestAnimationFrame(() => {
            tile.style.setProperty('--tx', `${endPos.x}px`);
            tile.style.setProperty('--ty', `${endPos.y}px`);
          });
        }
      }
      requestAnimationFrame(() => { isAnimating = false; });
    }

    function translate(x, y) {
      const { gap, size } = getMetrics();
      const offsetX = x * (size + gap);
      const offsetY = y * (size + gap);
      return { x: offsetX, y: offsetY };
    }

    function getMetrics() {
      const styles = getComputedStyle(document.documentElement);
      const gap = parseFloat(styles.getPropertyValue('--gap')) || 12;
      const size = (tilesEl.clientWidth - gap * (gridSize - 1)) / gridSize;
      return { gap, size };
    }

    function tileColors(value) {
      const map = {
        2: { bg: '#eee4da', fg: '#776e65' },
        4: { bg: '#ede0c8', fg: '#776e65' },
        8: { bg: '#f2b179', fg: '#f9f6f2' },
        16: { bg: '#f59563', fg: '#f9f6f2' },
        32: { bg: '#f67c5f', fg: '#f9f6f2' },
        64: { bg: '#f65e3b', fg: '#f9f6f2' },
        128: { bg: '#edcf72', fg: '#f9f6f2' },
        256: { bg: '#edcc61', fg: '#f9f6f2' },
        512: { bg: '#edc850', fg: '#f9f6f2' },
        1024: { bg: '#edc53f', fg: '#f9f6f2' },
        2048: { bg: '#edc22e', fg: '#f9f6f2' },
        4096: { bg: '#3c3a32', fg: '#f9f6f2' },
        8192: { bg: '#3b332a', fg: '#f9f6f2' },
        16384: { bg: '#3a2f26', fg: '#f9f6f2' },
        32768: { bg: '#392b22', fg: '#f9f6f2' },
        65536: { bg: '#38271e', fg: '#f9f6f2' },
        131072: { bg: '#37231a', fg: '#f9f6f2' },
      };
      return map[value] || { bg: '#3c3a32', fg: '#f9f6f2' };
    }

    function loadBestBySize() {
      try {
        const raw = localStorage.getItem('best-2048-by-size');
        if (raw) {
          const parsed = JSON.parse(raw);
          if (parsed && typeof parsed === 'object') return parsed;
        }
      } catch (e) {
        // ignore parse errors, fall back to legacy format
      }
      const legacy = Number(localStorage.getItem('best-2048') || 0);
      return legacy ? { '4': legacy } : {};
    }

    function saveBestBySize() {
      try {
        localStorage.setItem('best-2048-by-size', JSON.stringify(bestBySize));
      } catch (e) {
        // ignore quota errors
      }
    }

    function loadHistory() {
      try {
        const raw = localStorage.getItem('history-2048-records');
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed)) return parsed;
      } catch (e) {
        // ignore parse errors
      }
      return [];
    }

    function saveHistory() {
      try {
        localStorage.setItem('history-2048-records', JSON.stringify(historyRecords));
      } catch (e) {
        // ignore quota errors
      }
    }

    function finishTimerAndRecord() {
      if (!gameStartTime) return;
      const elapsedSec = Math.floor((Date.now() - gameStartTime) / 1000);
      // 没有实际操作（没有发生过移动）的对局不计入历史
      if (!hasPlayedCurrentGame) {
        stopTimer();
        gameStartTime = null;
        return;
      }
      stopTimer();
      const record = {
        size: gridSize,
        seconds: elapsedSec,
        score,
        startedAt: gameStartTime
      };
      historyRecords.unshift(record);
      if (historyRecords.length > 10) historyRecords.pop();
      saveHistory();
      renderHistory();
      gameStartTime = null;
    }

    function formatSeconds(totalSeconds) {
      const m = Math.floor(totalSeconds / 60);
      const s = totalSeconds % 60;
      return `${m}:${String(s).padStart(2, '0')}`;
    }

    function formatStartTime(timestamp) {
      const d = new Date(timestamp);
      const yyyy = d.getFullYear();
      const MM = String(d.getMonth() + 1).padStart(2, '0');
      const DD = String(d.getDate()).padStart(2, '0');
      const hh = String(d.getHours()).padStart(2, '0');
      const mm = String(d.getMinutes()).padStart(2, '0');
      const ss = String(d.getSeconds()).padStart(2, '0');
      return `${yyyy}-${MM}-${DD} ${hh}:${mm}:${ss}`;
    }

    function renderHistory() {
      if (!historyListEl) return;
      if (!historyRecords.length) {
        historyListEl.textContent = '暂无对局';
        return;
      }
      historyListEl.innerHTML = historyRecords
        .map((r, index) => {
          const startLabel = r.startedAt ? formatStartTime(r.startedAt) : '未知时间';
          return `<div class="history-item"><span>${startLabel} · ${r.size}×${r.size} · ${formatSeconds(r.seconds)} · ${r.score}分</span><button class="history-delete" data-index="${index}" aria-label="删除这一局记录">✕</button></div>`;
        })
        .join('');
    }

    function handleHistoryClick(e) {
      const btn = e.target && e.target.closest('.history-delete');
      if (!btn) return;
      const idx = Number(btn.getAttribute('data-index'));
      if (Number.isNaN(idx) || idx < 0 || idx >= historyRecords.length) return;
      historyRecords.splice(idx, 1);
      saveHistory();
      renderHistory();
    }

    function setupHistorySwipe() {
      const isTouch = 'ontouchstart' in window || (navigator && navigator.maxTouchPoints > 0);
      if (!isTouch || !historyListEl) return;
      historyListEl.addEventListener('touchstart', handleHistoryTouchStart, { passive: true });
      historyListEl.addEventListener('touchmove', handleHistoryTouchMove, { passive: false });
      historyListEl.addEventListener('touchend', handleHistoryTouchEnd);
    }

    function handleHistoryTouchStart(e) {
      if (e.touches.length !== 1) return;
      const item = e.target.closest('.history-item');
      if (!item) return;
      const t = e.touches[0];
      historySwipeState.item = item;
      historySwipeState.startX = t.clientX;
      historySwipeState.startY = t.clientY;
      historySwipeState.active = true;
      historySwipeState.moved = false;
    }

    function handleHistoryTouchMove(e) {
      if (!historySwipeState.active || e.touches.length !== 1) return;
      const t = e.touches[0];
      const dx = t.clientX - historySwipeState.startX;
      const dy = t.clientY - historySwipeState.startY;
      if (!historySwipeState.moved && Math.abs(dx) > 10 && Math.abs(dx) > Math.abs(dy)) {
        historySwipeState.moved = true;
      }
      if (!historySwipeState.moved) return;
      e.preventDefault();
      e.stopPropagation();
    }

    function handleHistoryTouchEnd(e) {
      if (!historySwipeState.active || !historySwipeState.item) {
        historySwipeState.active = false;
        historySwipeState.moved = false;
        historySwipeState.item = null;
        return;
      }
      const t = e.changedTouches[0];
      const dx = t.clientX - historySwipeState.startX;
      const dy = t.clientY - historySwipeState.startY;
      if (Math.abs(dx) > 30 && Math.abs(dx) > Math.abs(dy)) {
        if (dx < 0) {
          historySwipeState.item.classList.add('show-delete');
        } else {
          historySwipeState.item.classList.remove('show-delete');
        }
      }
      e.stopPropagation();
      historySwipeState.active = false;
      historySwipeState.moved = false;
      historySwipeState.item = null;
    }

    function handleBeforeUnload() {
      // 页面关闭或刷新时，将当前进行中的对局写入记录
      if (!gameStartTime) return;
      finishTimerAndRecord();
    }

    function addSwipe(target, callback) {
      let startX = 0, startY = 0;
      let isSwiping = false;

      target.addEventListener('touchstart', e => {
        if (e.touches.length !== 1) return;
        const t = e.touches[0];
        startX = t.clientX;
        startY = t.clientY;
        isSwiping = false;
      }, { passive: true });

      target.addEventListener('touchmove', e => {
        if (e.touches.length !== 1) return;
        const t = e.touches[0];
        const dx = t.clientX - startX;
        const dy = t.clientY - startY;
        const absX = Math.abs(dx);
        const absY = Math.abs(dy);
        if (!isSwiping && Math.max(absX, absY) > 10) {
          isSwiping = true;
        }
        if (isSwiping) {
          e.preventDefault();
        }
      }, { passive: false });

      target.addEventListener('touchend', e => {
        if (!isSwiping) return;
        const t = e.changedTouches[0];
        const dx = t.clientX - startX;
        const dy = t.clientY - startY;
        const absX = Math.abs(dx), absY = Math.abs(dy);
        if (Math.max(absX, absY) < 20) return;
        callback(absX > absY ? (dx > 0 ? 'right' : 'left') : (dy > 0 ? 'down' : 'up'));
      });
    }

    function cloneGrid(g) {
      return g.map(row => row.slice());
    }
  </script>
</body>
</html>
